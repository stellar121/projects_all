# SM2的软件实现优化 

## 一、SM2 加解密过程（基于椭圆曲线）

### 加密流程（发送方）：

生成随机数 $k ∈ [1, n-1]$

计算椭圆曲线点 C1 = kG

计算共享密钥点 S = kPB = (x2, y2)

使用 KDF(x2 || y2, klen) 生成密钥 t

计算 C2 = M ⊕ t（M 为明文）

计算哈希 C3 = Hash(x2 || M || y2)

输出密文：C = C1 || C3 || C2

### 解密流程（接收方）：

从密文中解析出 C1 = kG，C2，C3

验证 C1 是否为合法曲线点

计算 S = dB * C1 = (x2, y2)（私钥参与）

使用 KDF(x2 || y2, klen) 得到密钥 t

恢复明文 M = C2 ⊕ t

验证 C3 == Hash(x2 || M || y2) 是否成立

## 二、SM2 签名与验证过程

### 签名流程：

生成随机数 k ∈ [1, n-1]

计算 P1 = kG = (x1, y1)

计算摘要 e = Hash(ZA || M)，其中 ZA 为标识哈希

计算 $r = (e + x1) mod n；$若 r == 0 or r + k == n，则重签

计算 s = ((1 + dA)^-1 * (k - r * dA)) mod n；若 s == 0 重签

输出签名对：(r, s)

### 验证过程

验证 r, s ∈ [1, n-1]，否则拒绝

计算摘要 e = Hash(ZA || M)

计算 t = (r + s) mod n，若 t == 0，拒绝

计算点 P = sG + t * PA = (x1', y1')

计算 R = (e + x1') mod n

判断是否有 R == r


所有运算均在椭圆曲线定义的有限域 Fp 和群阶 n 下进行，ZA 为用户标识与公钥等组成的预处理哈希值，确保签名绑定身份，KDF 为密钥派生函数，通常基于 SM3 或其他哈希函数实现

ZA 为用户标识与公钥等组成的预处理哈希值，确保签名绑定身份

KDF 为密钥派生函数，通常基于 SM3 或其他哈希函数实现
