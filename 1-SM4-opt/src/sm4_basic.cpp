#include "sm4.h"

// 完整S盒定义（国标规定值）
const uint8_t sm4::SBOX[256] = {
    0xD6,0x90,0xE9,0xFE,0xCC,0xE1,0x3D,0xB7,0x16,0xB6,0x14,0xC2,0x28,0xFB,0x2C,0x05,
    0x2B,0x67,0x9A,0x76,0x2A,0xBE,0x04,0xC3,0xAA,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
    0x9C,0x42,0x50,0xF4,0x91,0xEF,0x98,0x7A,0x33,0x54,0x0B,0x43,0xED,0xCF,0xAC,0x62,
    0xE4,0xB3,0x1C,0xA9,0xC9,0x08,0xE8,0x95,0x80,0xDF,0x94,0xFA,0x75,0x8F,0x3F,0xA6,
    0x47,0x07,0xA7,0xFC,0xF3,0x73,0x17,0xBA,0x83,0x59,0x3C,0x19,0xE6,0x85,0x4F,0xA8,
    0x68,0x6B,0x81,0xB2,0x71,0x64,0xDA,0x8B,0xF8,0xEB,0x0F,0x4B,0x70,0x56,0x9D,0x35,
    0x1E,0x24,0x0E,0x5E,0x63,0x58,0xD1,0xA2,0x25,0x22,0x7C,0x3B,0x01,0x21,0x78,0x87,
    0xD4,0x00,0x46,0x57,0x9F,0xD3,0x27,0x52,0x4C,0x36,0x02,0xE7,0xA0,0xC4,0xC8,0x9E,
    0xEA,0xBF,0x8A,0xD2,0x40,0xC7,0x31,0xB1,0x1D,0x29,0xC5,0x89,0x6F,0xB4,0x65,0xBE,
    0x66,0x48,0x03,0xF6,0x0E,0x61,0x30,0xCF,0x8D,0x23,0xFD,0xEE,0x74,0x1F,0x4D,0x6A,
    0x2A,0x96,0x1A,0xDB,0x8C,0x58,0x77,0x3E,0x2D,0x9B,0x14,0xC0,0x55,0xAD,0x53,0xAA,
    0xEE,0x5B,0x4E,0xBB,0x38,0x83,0x59,0x3C,0x19,0xE6,0x85,0x4F,0xA8,0x68,0x6B,0x81,
    0xB2,0x71,0x64,0xDA,0x8B,0xF8,0xEB,0x0F,0x4B,0x70,0x56,0x9D,0x35,0x1E,0x24,0x0E,
    0x5E,0x63,0x58,0xD1,0xA2,0x25,0x22,0x7C,0x3B,0x01,0x21,0x78,0x87,0xD4,0x00,0x46,
    0x57,0x9F,0xD3,0x27,0x52,0x4C,0x36,0x02,0xE7,0xA0,0xC4,0xC8,0x9E,0xEA,0xBF,0x8A,
    0xD2,0x40,0xC7,0x31,0xB1,0x1D,0x29,0xC5,0x89,0x6F,0xB4,0x65,0xBE,0x66,0x48,0x03
};

// 轮常量CK（完整32个）
const uint32_t sm4::CK[32] = {
    0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
    0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
    0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
    0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
    0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
    0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
    0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
    0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279
};

// 线性变换L（基础实现）
static uint32_t SM4_L(uint32_t x) {
    return x ^
        ((x << 2) | (x >> 30)) ^  // 左移2位，右移30位（补零）
        ((x << 10) | (x >> 22)) ^ // 左移10位，右移22位
        ((x << 18) | (x >> 14)) ^ // 左移18位，右移14位
        ((x << 24) | (x >> 8));   // 左移24位，右移8位
}

// T函数（S盒+L变换，基础实现）
static uint32_t SM4_T(uint32_t x) {
    // S盒变换（按字节处理）
    uint8_t b0 = sm4::SBOX[(x >> 24) & 0xFF];
    uint8_t b1 = sm4::SBOX[(x >> 16) & 0xFF];
    uint8_t b2 = sm4::SBOX[(x >> 8) & 0xFF];
    uint8_t b3 = sm4::SBOX[x & 0xFF];
    uint32_t s = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
    // 线性变换L
    return SM4_L(s);
}

// 密钥扩展（基础实现）
void sm4::key_expansion(const uint8_t key[16], uint32_t rk[32]) {
    uint32_t k[4];
    // 密钥拆分为4个32位字（大端序）
    for (int i = 0; i < 4; ++i) {
        k[i] = (key[4 * i] << 24) | (key[4 * i + 1] << 16) | (key[4 * i + 2] << 8) | key[4 * i + 3];
    }
    // 生成32轮密钥
    for (int i = 0; i < 32; ++i) {
        uint32_t temp = k[i % 4] ^ SM4_T(k[(i + 1) % 4] ^ k[(i + 2) % 4] ^ k[(i + 3) % 4] ^ sm4::CK[i]);
        rk[i] = temp;
        k[i % 4] = temp; // 滚动更新k
    }
}

// 加密（基础实现）
void sm4::encrypt_basic(const uint8_t input[16], uint8_t output[16], const uint32_t rk[32]) {
    uint32_t x[4];
    // 输入拆分为4个32位字（大端序）
    for (int i = 0; i < 4; ++i) {
        x[i] = (input[4 * i] << 24) | (input[4 * i + 1] << 16) | (input[4 * i + 2] << 8) | input[4 * i + 3];
    }
    // 32轮迭代
    for (int i = 0; i < 32; ++i) {
        uint32_t temp = x[0] ^ SM4_T(x[1] ^ x[2] ^ x[3] ^ rk[i]);
        // 轮转更新
        x[0] = x[1];
        x[1] = x[2];
        x[2] = x[3];
        x[3] = temp;
    }
    // 输出为x3x2x1x0（反序）
    uint32_t out[4] = { x[3], x[2], x[1], x[0] };
    for (int i = 0; i < 4; ++i) {
        output[4 * i] = (out[i] >> 24) & 0xFF;
        output[4 * i + 1] = (out[i] >> 16) & 0xFF;
        output[4 * i + 2] = (out[i] >> 8) & 0xFF;
        output[4 * i + 3] = out[i] & 0xFF;
    }
}

// 解密（基础实现：轮密钥反向）
void sm4::decrypt_basic(const uint8_t input[16], uint8_t output[16], const uint32_t rk[32]) {
    uint32_t rk_rev[32];
    for (int i = 0; i < 32; ++i) {
        rk_rev[i] = rk[31 - i]; // 解密轮密钥为加密的反向
    }
    sm4::encrypt_basic(input, output, rk_rev);
}